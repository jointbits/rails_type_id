# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `typeid` gem.
# Please instead update this file by running `bin/tapioca gem typeid`.


# Represents a TypeID.
# Provides accessors to the underlying prefix, suffix, and UUID.
# Can be treated as a string.
#
# To generate a new +TypeID+:
#   TypeID.new("foo") #=> #<TypeID foo_01h4vjdvzefw18zfwz5dxw5y8g>
#
# To parse a +TypeID+ from a string:
#   TypeID.from_string("foo_01h4vjdvzefw18zfwz5dxw5y8g") #=> #<TypeID foo_01h4vjdvzefw18zfwz5dxw5y8g>
#
# To parse a +TypeID+ from a UUID:
#   TypeID.from_uuid("foo", "01893726-efee-7f02-8fbf-9f2b7bc2f910") #=> #<TypeID foo_01h4vjdvzefw18zfwz5dxw5y8g>
#
# To create a +TypeID+ from a timestamp (in milliseconds since the Unix epoch):
#   TypeID.new("foo", timestamp: 1688847445998) #=> #<TypeID foo_01h4vjdvzefw18zfwz5dxw5y8g>
#
# source://typeid//lib/typeid/uuid/base32.rb#1
class TypeID < ::String
  # Creates a +TypeID+ given a prefix and an optional suffix or timestamp (in milliseconds since the Unix epoch).
  # When given only a prefix, generates a new +TypeID+.
  # When +suffix+ or +timestamp+ is provided, creates a +TypeID+ from the given value.
  #
  # @param prefix [String]
  # @param timestamp [Integer] milliseconds since the Unix epoch
  # @param suffix [String] base32-encoded UUID
  # @raise [Error]
  # @return [TypeID] a new instance of TypeID
  #
  # source://typeid//lib/typeid.rb#80
  def initialize(prefix, timestamp: T.unsafe(nil), suffix: T.unsafe(nil)); end

  # @return [String]
  #
  # source://typeid//lib/typeid.rb#106
  def inspect; end

  # @return [String]
  #
  # source://typeid//lib/typeid.rb#24
  def prefix; end

  # @return [String]
  #
  # source://typeid//lib/typeid.rb#27
  def suffix; end

  # @return [String]
  #
  # source://typeid//lib/typeid.rb#28
  def type; end

  # Returns the UUID component of the +TypeID+, parsed from the suffix.
  #
  # @return [TypeID::UUID]
  #
  # source://typeid//lib/typeid.rb#101
  def uuid; end

  private

  # @return [String]
  #
  # source://typeid//lib/typeid.rb#113
  def string; end

  class << self
    # Creates a +TypeID+ given a prefix string and a suffix string.
    #
    # @param prefix [String]
    # @param suffix [String]
    # @return [TypeID]
    #
    # source://typeid//lib/typeid.rb#62
    def from(prefix, suffix); end

    # Parses a +TypeID+ from a string.
    #
    # @param string [String] string representation of a +TypeID+
    # @return [TypeID]
    #
    # source://typeid//lib/typeid.rb#34
    def from_string(string); end

    # Parses a +TypeID+ given a prefix and a raw UUID string.
    #
    # @param prefix [String]
    # @param uuid [String]
    # @return [TypeID]
    #
    # source://typeid//lib/typeid.rb#53
    def from_uuid(prefix, uuid); end

    # Returns the +nil+ TypeID.
    #
    # @return [TypeID]
    #
    # source://typeid//lib/typeid.rb#69
    def nil; end
  end
end

# source://typeid//lib/typeid.rb#21
class TypeID::Error < ::StandardError; end

# source://typeid//lib/typeid.rb#19
TypeID::MAX_PREFIX_LENGTH = T.let(T.unsafe(nil), Integer)

# Represents a UUID. Can be treated as a string.
#
# source://typeid//lib/typeid/uuid/base32.rb#2
class TypeID::UUID < ::String
  # Initializes a +UUID+ from an array of bytes.
  #
  # @param bytes [Array<Integer>] size 16 byte array
  # @return [UUID] a new instance of UUID
  #
  # source://typeid//lib/typeid/uuid.rb#50
  def initialize(bytes); end

  # Returns the +UUID+ encoded as a base32 +String+.
  #
  # @return [String]
  #
  # source://typeid//lib/typeid/uuid.rb#59
  def base32; end

  # @return [Array<Integer>]
  #
  # source://typeid//lib/typeid/uuid.rb#8
  def bytes; end

  # @return [String]
  #
  # source://typeid//lib/typeid/uuid.rb#73
  def inspect; end

  # Returns the timestamp of the +UUID+ as milliseconds since the Unix epoch.
  #
  # @return [Integer]
  #
  # source://typeid//lib/typeid/uuid.rb#66
  def timestamp; end

  private

  # @return [String]
  #
  # source://typeid//lib/typeid/uuid.rb#80
  def string; end

  class << self
    # Parses a +UUID+ from a base32 +String+.
    #
    # @param string [String] base32-encoded UUID
    # @return [TypeID::UUID]
    #
    # source://typeid//lib/typeid/uuid.rb#29
    def from_base32(string); end

    # Parses a +UUID+ from a raw +String+.
    #
    # @param string [String] raw UUID
    # @return [TypeID::UUID]
    #
    # source://typeid//lib/typeid/uuid.rb#37
    def from_string(string); end

    # Generates a new +UUID+, using gem "uuid7".
    #
    # @param timestamp [Integer] milliseconds since the Unix epoch
    # @return [TypeID::UUID]
    #
    # source://typeid//lib/typeid/uuid.rb#21
    def generate(timestamp: T.unsafe(nil)); end

    # Utility method to generate a timestamp as milliseconds since the Unix epoch.
    #
    # @return [Integer]
    #
    # source://typeid//lib/typeid/uuid.rb#13
    def timestamp; end
  end
end

# Provides utilities for encoding and decoding UUIDs to and from base32.
# Based on https://github.com/jetpack-io/typeid-go/blob/341e2b135e0609db272e6400f2f551487725824a/base32/base32.go.
#
# source://typeid//lib/typeid/uuid/base32.rb#6
module TypeID::UUID::Base32
  class << self
    # Decodes a size 26 +String+ into a size 16 byte +Array+.
    # Based on https://github.com/jetpack-io/typeid-go/blob/341e2b135e0609db272e6400f2f551487725824a/base32/base32.go#L82.
    # Each line needs an extra `& 0xFF` because the elements are +Integer+s, which don't truncate on left shifts.
    #
    # @param string [String] size 26 base32-encoded string
    # @raise [Error]
    # @return [Array<Integer>]
    #
    # source://typeid//lib/typeid/uuid/base32.rb#95
    def decode(string); end

    # Encodes a size 16 byte +Array+ into a size 26 +String+.
    # Based on https://github.com/jetpack-io/typeid-go/blob/341e2b135e0609db272e6400f2f551487725824a/base32/base32.go#L14.
    #
    # @param bytes [Array<Integer>] size 16 byte array
    # @raise [Error]
    # @return [String]
    #
    # source://typeid//lib/typeid/uuid/base32.rb#51
    def encode(bytes); end
  end
end

# Crockford's Base32 alphabet.
#
# source://typeid//lib/typeid/uuid/base32.rb#13
TypeID::UUID::Base32::ALPHABET = T.let(T.unsafe(nil), String)

# Byte to index table for O(1) lookups when unmarshaling.
# We use 0xFF as sentinel value for invalid indexes.
#
# source://typeid//lib/typeid/uuid/base32.rb#17
TypeID::UUID::Base32::DEC = T.let(T.unsafe(nil), Array)

# source://typeid//lib/typeid/uuid/base32.rb#7
TypeID::UUID::Base32::DECODED_BYTE_ARRAY_LENGTH = T.let(T.unsafe(nil), Integer)

# source://typeid//lib/typeid/uuid/base32.rb#8
TypeID::UUID::Base32::ENCODED_STRING_LENGTH = T.let(T.unsafe(nil), Integer)

# source://typeid//lib/typeid/uuid/base32.rb#10
class TypeID::UUID::Base32::Error < ::StandardError; end
